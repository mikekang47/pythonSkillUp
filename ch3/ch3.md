### ch03
#### 3.1 파이썬 리스트 생성 및 활용
---
리스트 생성은 간단하다.

```python
beat_list = ['John', 'Paul', 'George', 'Ringo']

# 문자열과 숫자 데이터를 섞을 수도 있다.
mixed_list = [10, "John", 5, "Paul"]

# 손쉽게 정렬도 가능하다.
num_list = [3,2,17, 2.5]
num_list.sort() #2, 2.5, 3, 17로 정렬
```
<br>

#### 3.2 리스트 복사 vs 리스트 변수 복사
---
``a_list = [2,5,10]``
``b_list = a_list``

위 코드는 리스트 변수 복사다.
변수 복사의 단점은 b_list에 값을 추가하면 a_list에도 추가된다는 단점이 있다.

그래서 이 문제를 해결하기 위해서는 항목간 복사를 사용한다.

``my_list = [1, 10, 5]``
``yr_list = my_list[:]``

이렇게 복사 하면 분리된 서로 다른 복제본을 참조하고 있기 때문에 서로 영향을 받지 않는다.

<br>

#### 3.3 인덱스
---
리스트에 양수 인덱스 접수는 기본이고, 음수 인덱스 접근까지 가능하다.

음수 인덱스는 가장 뒤에있는 것이 -1이고 점점 인덱스가 증가해 len(arr)까지 증가한다.

enumerate로 인덱스 숫자 생성도 가능하다.

인덱스가 항상 변화하는 상황에서 저장해서 활용하면 아주 편리하다.

<br>

##### 3.4 조각으로부터 데이터 가져오기
---
파이썬의 인덱싱은 파이썬의 장점 중 하나이다.

```python
list[시작:종료] #시작부터 종료-1까지의 리스트 항목 반환
list[:종료] #처음부터 종료-1까지 리스트 항목 반환
list[:] #리스트 모든 항목 반환
list[시작:종료:스텝] #거리가 1이 아닌 '스텝' 크기인 항목들을 반환.
```

매우 매우 중요하다.

<br>

#### 3.5 조각 안에 값 대입하기
---
ㄴ
`my_list = [10, 20, 30, 40, 50, 60]`
`my_list[1:4] = [707, 777]` 이렇게 하면
`print(my_list) #[10, 707 777, 50 ,60]` 이 된다.

인덱스를 밀어버리고, 그 자리에 대체하는 것이다.

<br>

#### 3.6 리스트 연산자
---
다들 기본적인 연산자들은 알고 있을 것으로 생각된다.

파이썬에서 볼 수 있는 연산자들의 경우

`리스트1 + 리스트 2 #이어붙이기`

`리스트1 = 리스트2[:] #항목 복사`

`항목 in 리스트 #리스트 내에 항목이 존재하면 True를 반환`

정도이다.

<br>

#### 3.7 얕은 복사 vs 깊은 복사
---
앞에서도 다뤘지만 파이썬은 얕은 복사와 깊은 복사가 있다.

복사는 파이썬에서 아주 중요하게 다루고 있는 주제이다.

`a_list = [1, 2, [5,10]]`
`b_list = a_list[:]` 라고 선언하자.

``` python
b_list[0] = 0
b_list[1] = 0
b_list[2][0] = 0
b_list[2][1] = 0
```

위 코드의 기댓값은 b_list가 모두 0으로 변경되고
a_list는 그대로 `[1, 2, [5,10]]` 인 것이다.

하지만 결과는 처참하다.

``` python
print(a_list)
#[1,2,[0,0]]
```

얕은 복사는 다른 객체를 가리키도록 처리되지만,
리스트 안에 있는 리스트는 여전히 같은 리스트를 참조하고 있다.

그렇기 때문에 이런 현상이 발생하는 것이다.

이를 해결하기 위해서는 깊은 복사를 해야한다.

깊은 복사는 아래처럼 실행할 수 있다.

``` python
import copy
b_list = copy.deepcopy(a_list)
```

<br>

#### 3.8 리스트 함수
---
리스트 함수는 유용한 것들이 많다.

얘네들은 함수다.(메서드가 아니고)

`len, max, min, reversed, sorted, sum`

다들 뭘 반환하는지 알 것이라 생각된다.

<br>

#### 3.9 리스트 메서드: 내용 정보 수정하기
---
수정에는 별것이 없다.

추가에 append

모든 항목 제거에 clear()

하위 리스트를 추가하는 extend

인덱스 위치에 값 삽입 insert(인덱스, 값)

값의 첫 인스터스를 삭제하는 remove(값)


<br>

#### 3.10 리스트 메서드: 내용 정보 가져오기
---
```python
li = []
li.count(값)
li.index(값,[시작, [, 종료]])
li.pop([인덱스])
```
index에 값만을 입력하면 가장 먼저 나오는 녀석만을 반환해주기 때문에

c++의 lowerbound나 upperbound의 흉내를 내고싶다면

인덱스 값을 지정해주는게 좋다.

pop의 경우 인덱스 기본값은 당연하게도 마지막 인덱스이기 때문에

앞 인덱스 값을 제거하고 싶거나, 중간 것을 제거하고 싶다면 인덱스를 지정해주면 된다.

<br>

#### 3.11 리스트 메서드: 재편성하기
---
리스트 자체를 변경하는 
list.sort()
list.reverse()가 있다.

<br>

#### 3.12 스택 역할을 하는 리스트: RPN 애플리케이션
---
이 글을 보는 여러분은 당연히 스택이 뭔지, 
스택의 특성이 LIFO 인것을 알 것이다.

그리고 파이썬의 리스트가 스택의 역할을 하는 것도 눈치 챘을 것이다.

그래서 자세한 설명은 생략한다.

혹시 스택이 뭔지 궁금하다면 
아래 링크로.

[스택 설명](https://mirrorofcode.tistory.com/43?category=484705)





